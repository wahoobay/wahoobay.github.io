"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof3 = require("@babel/runtime/helpers/typeof");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _react = _interopRequireWildcard(require("react"));

var _AsyncTypeahead = _interopRequireDefault(require("./AsyncTypeahead"));

var _helpers = require("../../tests/helpers");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof3(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var TestComponent = function TestComponent(props) {
  var _useState = (0, _react.useState)(false),
      _useState2 = (0, _slicedToArray2["default"])(_useState, 2),
      isLoading = _useState2[0],
      setIsLoading = _useState2[1];

  return /*#__PURE__*/_react["default"].createElement(_AsyncTypeahead["default"], (0, _extends2["default"])({
    delay: 0,
    id: "async-test",
    minLength: 0,
    onChange: _helpers.noop,
    selected: []
  }, props, {
    isLoading: isLoading,
    onSearch: function onSearch(query) {
      (0, _helpers.act)(function () {
        setIsLoading(true);
      });
      props.onSearch && props.onSearch(query);
      (0, _helpers.act)(function () {
        setIsLoading(false);
      });
    }
  }));
};

describe('<AsyncTypeahead>', function () {
  it('displays a search prompt', /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
    var promptText, items;
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            promptText = 'Prompt text';
            (0, _helpers.render)( /*#__PURE__*/_react["default"].createElement(TestComponent, {
              promptText: promptText
            }));
            (0, _helpers.getInput)().focus();
            _context.next = 5;
            return (0, _helpers.findItems)();

          case 5:
            items = _context.sent;
            expect(items).toHaveLength(1);
            expect(items[0]).toHaveTextContent(promptText);

          case 8:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  })));
  it('displays the search text while searching', /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
    var searchText;
    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            searchText = 'Search text';
            (0, _helpers.render)( /*#__PURE__*/_react["default"].createElement(TestComponent, {
              onSearch: function onSearch() {
                var items = (0, _helpers.getItems)();
                expect(items).toHaveLength(1);
                expect(items[0]).toHaveTextContent(searchText);
              },
              searchText: searchText
            }));

            _helpers.userEvent.type((0, _helpers.getInput)(), 'search'); // TODO: Fix async behaviors so component correctly displays search text
            // when `isLoading` is true.


            _context2.next = 5;
            return (0, _helpers.waitForOverlay)();

          case 5:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  })));
  it('displays the empty label when there are no results', /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3() {
    var emptyLabel, items;
    return _regenerator["default"].wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            emptyLabel = 'empty label';
            (0, _helpers.render)( /*#__PURE__*/_react["default"].createElement(TestComponent, {
              emptyLabel: emptyLabel
            }));

            _helpers.userEvent.type((0, _helpers.getInput)(), 'foo');

            _context3.next = 5;
            return (0, _helpers.findItems)();

          case 5:
            items = _context3.sent;
            expect(items).toHaveLength(1);
            expect(items[0]).toHaveTextContent(emptyLabel);

          case 8:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  })));
  it('displays the empty label when the input has an initial value', /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4() {
    var emptyLabel, items;
    return _regenerator["default"].wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            emptyLabel = 'empty label';
            (0, _helpers.render)( /*#__PURE__*/_react["default"].createElement(_AsyncTypeahead["default"], {
              defaultInputValue: "sometext",
              delay: 0,
              emptyLabel: emptyLabel,
              id: "async-empty-label-test",
              isLoading: false,
              onSearch: _helpers.noop,
              options: [],
              useCache: false
            }));
            (0, _helpers.getInput)().focus();
            _context4.next = 5;
            return (0, _helpers.findItems)();

          case 5:
            items = _context4.sent;
            expect(items).toHaveLength(1);
            expect(items[0]).toHaveTextContent(emptyLabel);

          case 8:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  })));
  it('delays the search by at least the specified amount', /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee5() {
    var delay, preSearch;
    return _regenerator["default"].wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            delay = 100;
            preSearch = Date.now();
            (0, _helpers.render)( /*#__PURE__*/_react["default"].createElement(TestComponent, {
              delay: delay
            }));

            _helpers.userEvent.type((0, _helpers.getInput)(), 'search');

            _context5.next = 6;
            return (0, _helpers.waitForOverlay)();

          case 6:
            expect(Date.now() - preSearch).toBeGreaterThanOrEqual(delay);

          case 7:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  })));
  it('does not call onSearch when a selection is made', function () {
    var onChange = jest.fn();
    var onSearch = jest.fn();
    (0, _helpers.render)( /*#__PURE__*/_react["default"].createElement(TestComponent, {
      onChange: onChange,
      onSearch: onSearch,
      options: ['one', 'two', 'four']
    }));
    (0, _helpers.getInput)().focus();

    _helpers.userEvent.keyboard('{arrowdown}{enter}');

    expect(onChange).toHaveBeenCalledTimes(1);
    expect(onSearch).toHaveBeenCalledTimes(0);
  });
  it('uses cached results and does not perform a new search', /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee6() {
    var onSearch, input;
    return _regenerator["default"].wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            onSearch = jest.fn();
            (0, _helpers.render)( /*#__PURE__*/_react["default"].createElement(TestComponent, {
              onSearch: onSearch,
              useCache: true
            }));
            input = (0, _helpers.getInput)();

            _helpers.userEvent.type(input, 'foo');

            _context6.next = 6;
            return (0, _helpers.waitFor)(function () {
              expect(onSearch).toHaveBeenCalledTimes(1);
            });

          case 6:
            _helpers.userEvent.clear(input);

            _helpers.userEvent.type(input, 'bar');

            _context6.next = 10;
            return (0, _helpers.waitFor)(function () {
              expect(onSearch).toHaveBeenCalledTimes(2);
            });

          case 10:
            _helpers.userEvent.clear(input);

            _helpers.userEvent.type(input, 'foo');

            _context6.next = 14;
            return (0, _helpers.waitFor)(function () {
              expect(onSearch).toHaveBeenCalledTimes(2);
            });

          case 14:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  })));
  it('does not use cached results', /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee7() {
    var onSearch, input;
    return _regenerator["default"].wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            onSearch = jest.fn();
            (0, _helpers.render)( /*#__PURE__*/_react["default"].createElement(TestComponent, {
              onSearch: onSearch,
              useCache: false
            }));
            input = (0, _helpers.getInput)();

            _helpers.userEvent.type(input, 'search');

            _context7.next = 6;
            return (0, _helpers.waitFor)(function () {
              expect(onSearch).toHaveBeenCalledTimes(1);
            });

          case 6:
            _helpers.userEvent.clear(input);

            _helpers.userEvent.type(input, 'search');

            _context7.next = 10;
            return (0, _helpers.waitFor)(function () {
              expect(onSearch).toHaveBeenCalledTimes(2);
            });

          case 10:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7);
  })));
  it('does not call `onSearch` with an empty query', function () {
    var onInputChange = jest.fn();
    var onSearch = jest.fn();
    (0, _helpers.render)( /*#__PURE__*/_react["default"].createElement(TestComponent, {
      defaultInputValue: "x",
      minLength: 2,
      onInputChange: onInputChange,
      onSearch: onSearch
    }));
    var input = (0, _helpers.getInput)();
    expect(input).toHaveValue('x');
    input.focus();

    _helpers.userEvent.keyboard('{backspace}');

    expect(input).toHaveValue('');
    expect(onInputChange).toHaveBeenCalledTimes(1);
    expect(onSearch).toHaveBeenCalledTimes(0);
  });
  it('does not call `onSearch` if query is less than `minLength`', function () {
    var onInputChange = jest.fn();
    var onSearch = jest.fn();
    (0, _helpers.render)( /*#__PURE__*/_react["default"].createElement(TestComponent, {
      minLength: 2,
      onInputChange: onInputChange,
      onSearch: onSearch
    }));

    _helpers.userEvent.type((0, _helpers.getInput)(), 'x');

    expect(onInputChange).toHaveBeenCalledTimes(1);
    expect(onSearch).toHaveBeenCalledTimes(0);
  });
  it('performs a search when there is already a selection', /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee8() {
    var onSearch;
    return _regenerator["default"].wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            onSearch = jest.fn();
            (0, _helpers.render)( /*#__PURE__*/_react["default"].createElement(TestComponent, {
              multiple: true,
              onSearch: onSearch,
              options: ['one', 'two'],
              selected: ['one']
            }));
            expect(onSearch).toHaveBeenCalledTimes(0);

            _helpers.userEvent.type((0, _helpers.getInput)(), 'foo');

            _context8.next = 6;
            return (0, _helpers.waitFor)(function () {
              expect(onSearch).toHaveBeenCalledTimes(1);
            });

          case 6:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8);
  })));
  it('receives an event as the second argument of `onInputChange`', function () {
    (0, _helpers.render)( /*#__PURE__*/_react["default"].createElement(TestComponent, {
      minLength: 2,
      onInputChange: function onInputChange(text, e) {
        expect(text).toBe('x');
        expect(e).toBeDefined();
      }
    }));

    _helpers.userEvent.type((0, _helpers.getInput)(), 'x');
  });
  it('displays a custom option when `allowNew` function returns true', /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee9() {
    var items;
    return _regenerator["default"].wrap(function _callee9$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            (0, _helpers.render)( /*#__PURE__*/_react["default"].createElement(TestComponent, {
              allowNew: function allowNew() {
                return true;
              }
            }));

            _helpers.userEvent.type((0, _helpers.getInput)(), 'zzz');

            _context9.next = 4;
            return (0, _helpers.findItems)();

          case 4:
            items = _context9.sent;
            expect(items).toHaveLength(1);
            expect(items[0]).toHaveTextContent('zzz');

          case 7:
          case "end":
            return _context9.stop();
        }
      }
    }, _callee9);
  })));
  it('disables `allowNew` while results are loading', /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee10() {
    return _regenerator["default"].wrap(function _callee10$(_context10) {
      while (1) {
        switch (_context10.prev = _context10.next) {
          case 0:
            (0, _helpers.render)( /*#__PURE__*/_react["default"].createElement(TestComponent, {
              allowNew: true,
              onSearch: function onSearch() {
                var items = (0, _helpers.getItems)();
                expect(items).toHaveLength(1);
                expect(items[0]).toHaveTextContent('Searching...');
              }
            }));

            _helpers.userEvent.type((0, _helpers.getInput)(), 'zzz');

            _context10.next = 4;
            return (0, _helpers.waitFor)(function () {
              expect((0, _helpers.getItems)()[0]).toHaveTextContent('zzz');
            });

          case 4:
          case "end":
            return _context10.stop();
        }
      }
    }, _callee10);
  })));
  it('exposes the typeahead instance and public methods', function () {
    var ref = /*#__PURE__*/(0, _react.createRef)();
    (0, _helpers.render)( /*#__PURE__*/_react["default"].createElement(_AsyncTypeahead["default"], {
      id: "async-instance-test",
      isLoading: false,
      onSearch: _helpers.noop,
      options: [],
      ref: ref
    }));
    ['clear', 'blur', 'focus', 'getInput'].forEach(function (method) {
      expect((0, _typeof2["default"])(ref.current[method])).toBe('function');
    });
  });
});
import _typeof from "@babel/runtime/helpers/typeof";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _extends from "@babel/runtime/helpers/extends";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import React, { createRef, useState } from 'react';
import AsyncTypeahead from './AsyncTypeahead';
import { act, findItems, getInput, getItems, noop, render, userEvent, waitFor, waitForOverlay } from '../../tests/helpers';

var TestComponent = function TestComponent(props) {
  var _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      isLoading = _useState2[0],
      setIsLoading = _useState2[1];

  return /*#__PURE__*/React.createElement(AsyncTypeahead, _extends({
    delay: 0,
    id: "async-test",
    minLength: 0,
    onChange: noop,
    selected: []
  }, props, {
    isLoading: isLoading,
    onSearch: function onSearch(query) {
      act(function () {
        setIsLoading(true);
      });
      props.onSearch && props.onSearch(query);
      act(function () {
        setIsLoading(false);
      });
    }
  }));
};

describe('<AsyncTypeahead>', function () {
  it('displays a search prompt', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
    var promptText, items;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            promptText = 'Prompt text';
            render( /*#__PURE__*/React.createElement(TestComponent, {
              promptText: promptText
            }));
            getInput().focus();
            _context.next = 5;
            return findItems();

          case 5:
            items = _context.sent;
            expect(items).toHaveLength(1);
            expect(items[0]).toHaveTextContent(promptText);

          case 8:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  })));
  it('displays the search text while searching', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
    var searchText;
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            searchText = 'Search text';
            render( /*#__PURE__*/React.createElement(TestComponent, {
              onSearch: function onSearch() {
                var items = getItems();
                expect(items).toHaveLength(1);
                expect(items[0]).toHaveTextContent(searchText);
              },
              searchText: searchText
            }));
            userEvent.type(getInput(), 'search'); // TODO: Fix async behaviors so component correctly displays search text
            // when `isLoading` is true.

            _context2.next = 5;
            return waitForOverlay();

          case 5:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  })));
  it('displays the empty label when there are no results', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
    var emptyLabel, items;
    return _regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            emptyLabel = 'empty label';
            render( /*#__PURE__*/React.createElement(TestComponent, {
              emptyLabel: emptyLabel
            }));
            userEvent.type(getInput(), 'foo');
            _context3.next = 5;
            return findItems();

          case 5:
            items = _context3.sent;
            expect(items).toHaveLength(1);
            expect(items[0]).toHaveTextContent(emptyLabel);

          case 8:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  })));
  it('displays the empty label when the input has an initial value', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {
    var emptyLabel, items;
    return _regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            emptyLabel = 'empty label';
            render( /*#__PURE__*/React.createElement(AsyncTypeahead, {
              defaultInputValue: "sometext",
              delay: 0,
              emptyLabel: emptyLabel,
              id: "async-empty-label-test",
              isLoading: false,
              onSearch: noop,
              options: [],
              useCache: false
            }));
            getInput().focus();
            _context4.next = 5;
            return findItems();

          case 5:
            items = _context4.sent;
            expect(items).toHaveLength(1);
            expect(items[0]).toHaveTextContent(emptyLabel);

          case 8:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  })));
  it('delays the search by at least the specified amount', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {
    var delay, preSearch;
    return _regeneratorRuntime.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            delay = 100;
            preSearch = Date.now();
            render( /*#__PURE__*/React.createElement(TestComponent, {
              delay: delay
            }));
            userEvent.type(getInput(), 'search');
            _context5.next = 6;
            return waitForOverlay();

          case 6:
            expect(Date.now() - preSearch).toBeGreaterThanOrEqual(delay);

          case 7:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  })));
  it('does not call onSearch when a selection is made', function () {
    var onChange = jest.fn();
    var onSearch = jest.fn();
    render( /*#__PURE__*/React.createElement(TestComponent, {
      onChange: onChange,
      onSearch: onSearch,
      options: ['one', 'two', 'four']
    }));
    getInput().focus();
    userEvent.keyboard('{arrowdown}{enter}');
    expect(onChange).toHaveBeenCalledTimes(1);
    expect(onSearch).toHaveBeenCalledTimes(0);
  });
  it('uses cached results and does not perform a new search', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {
    var onSearch, input;
    return _regeneratorRuntime.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            onSearch = jest.fn();
            render( /*#__PURE__*/React.createElement(TestComponent, {
              onSearch: onSearch,
              useCache: true
            }));
            input = getInput();
            userEvent.type(input, 'foo');
            _context6.next = 6;
            return waitFor(function () {
              expect(onSearch).toHaveBeenCalledTimes(1);
            });

          case 6:
            userEvent.clear(input);
            userEvent.type(input, 'bar');
            _context6.next = 10;
            return waitFor(function () {
              expect(onSearch).toHaveBeenCalledTimes(2);
            });

          case 10:
            userEvent.clear(input);
            userEvent.type(input, 'foo');
            _context6.next = 14;
            return waitFor(function () {
              expect(onSearch).toHaveBeenCalledTimes(2);
            });

          case 14:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  })));
  it('does not use cached results', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {
    var onSearch, input;
    return _regeneratorRuntime.wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            onSearch = jest.fn();
            render( /*#__PURE__*/React.createElement(TestComponent, {
              onSearch: onSearch,
              useCache: false
            }));
            input = getInput();
            userEvent.type(input, 'search');
            _context7.next = 6;
            return waitFor(function () {
              expect(onSearch).toHaveBeenCalledTimes(1);
            });

          case 6:
            userEvent.clear(input);
            userEvent.type(input, 'search');
            _context7.next = 10;
            return waitFor(function () {
              expect(onSearch).toHaveBeenCalledTimes(2);
            });

          case 10:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7);
  })));
  it('does not call `onSearch` with an empty query', function () {
    var onInputChange = jest.fn();
    var onSearch = jest.fn();
    render( /*#__PURE__*/React.createElement(TestComponent, {
      defaultInputValue: "x",
      minLength: 2,
      onInputChange: onInputChange,
      onSearch: onSearch
    }));
    var input = getInput();
    expect(input).toHaveValue('x');
    input.focus();
    userEvent.keyboard('{backspace}');
    expect(input).toHaveValue('');
    expect(onInputChange).toHaveBeenCalledTimes(1);
    expect(onSearch).toHaveBeenCalledTimes(0);
  });
  it('does not call `onSearch` if query is less than `minLength`', function () {
    var onInputChange = jest.fn();
    var onSearch = jest.fn();
    render( /*#__PURE__*/React.createElement(TestComponent, {
      minLength: 2,
      onInputChange: onInputChange,
      onSearch: onSearch
    }));
    userEvent.type(getInput(), 'x');
    expect(onInputChange).toHaveBeenCalledTimes(1);
    expect(onSearch).toHaveBeenCalledTimes(0);
  });
  it('performs a search when there is already a selection', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {
    var onSearch;
    return _regeneratorRuntime.wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            onSearch = jest.fn();
            render( /*#__PURE__*/React.createElement(TestComponent, {
              multiple: true,
              onSearch: onSearch,
              options: ['one', 'two'],
              selected: ['one']
            }));
            expect(onSearch).toHaveBeenCalledTimes(0);
            userEvent.type(getInput(), 'foo');
            _context8.next = 6;
            return waitFor(function () {
              expect(onSearch).toHaveBeenCalledTimes(1);
            });

          case 6:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8);
  })));
  it('receives an event as the second argument of `onInputChange`', function () {
    render( /*#__PURE__*/React.createElement(TestComponent, {
      minLength: 2,
      onInputChange: function onInputChange(text, e) {
        expect(text).toBe('x');
        expect(e).toBeDefined();
      }
    }));
    userEvent.type(getInput(), 'x');
  });
  it('displays a custom option when `allowNew` function returns true', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {
    var items;
    return _regeneratorRuntime.wrap(function _callee9$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            render( /*#__PURE__*/React.createElement(TestComponent, {
              allowNew: function allowNew() {
                return true;
              }
            }));
            userEvent.type(getInput(), 'zzz');
            _context9.next = 4;
            return findItems();

          case 4:
            items = _context9.sent;
            expect(items).toHaveLength(1);
            expect(items[0]).toHaveTextContent('zzz');

          case 7:
          case "end":
            return _context9.stop();
        }
      }
    }, _callee9);
  })));
  it('disables `allowNew` while results are loading', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {
    return _regeneratorRuntime.wrap(function _callee10$(_context10) {
      while (1) {
        switch (_context10.prev = _context10.next) {
          case 0:
            render( /*#__PURE__*/React.createElement(TestComponent, {
              allowNew: true,
              onSearch: function onSearch() {
                var items = getItems();
                expect(items).toHaveLength(1);
                expect(items[0]).toHaveTextContent('Searching...');
              }
            }));
            userEvent.type(getInput(), 'zzz');
            _context10.next = 4;
            return waitFor(function () {
              expect(getItems()[0]).toHaveTextContent('zzz');
            });

          case 4:
          case "end":
            return _context10.stop();
        }
      }
    }, _callee10);
  })));
  it('exposes the typeahead instance and public methods', function () {
    var ref = /*#__PURE__*/createRef();
    render( /*#__PURE__*/React.createElement(AsyncTypeahead, {
      id: "async-instance-test",
      isLoading: false,
      onSearch: noop,
      options: [],
      ref: ref
    }));
    ['clear', 'blur', 'focus', 'getInput'].forEach(function (method) {
      expect(_typeof(ref.current[method])).toBe('function');
    });
  });
});